// Copyright 2017-2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//
//! [`Swarm`]: libp2p_swarm::Swarm
//! [`Transport`]: libp2p_core::Transport

// example from Msg
//

mod handler;
mod protocol;

pub use protocol::MsgContent;

use handler::Handler;
pub use handler::{Success};
use libp2p::core::{connection::ConnectionId, PeerId};
use libp2p::swarm::{NetworkBehaviour, NetworkBehaviourAction, NotifyHandler,PollParameters};
use std::{
    collections::VecDeque,
    task::{Context, Poll},
};

use std::collections::hash_map::{HashMap};
use smallvec::SmallVec;

#[deprecated(
    since = "0.30.0",
    note = "Use re-exports that omit `Msg` prefix, i.e.  etc"
)]

pub use self::{
    Event as StreamEvent, Result as StreamResult,
    Success as StreamSuccess,
};

#[deprecated(since = "0.30.0", note = "Use librust_examples::Behaviour instead.")]

use std::io::Error;
/// The result of an inbound or outbound stream.
pub type Result = std::result::Result<Success,Error>;

/// A [`NetworkBehaviour`] that responds to inbound pings and
/// periodically sends outbound pings on every established connection.
///
/// See the crate root documentation for more information.
pub struct Behaviour {
    /// Queue of events to yield to the swarm.
    events: VecDeque<NetworkBehaviourAction<Event,Handler>>,

    /// List of peers to send messages to.
    target_peers: HashMap<PeerId, SmallVec<[i32; 8]>>,

}


/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct Event {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound ping.
    pub result: protocol::MsgContent,
}

impl Behaviour {
    /// Creates a new `Ping` network behaviour with the given configuration.
    pub fn new() -> Self {
        Self {
            events: VecDeque::new(),
            target_peers: HashMap::new(),
        }
    }

    pub fn send(&mut self,data: impl Into<Vec<u8>>) {

        let d = data.into();

        for peer in self.target_peers.keys() {
            self.events
                 .push_back(
                        NetworkBehaviourAction::NotifyHandler {
                            peer_id:*peer,
                            handler: NotifyHandler::Any,
                            event: protocol::MsgContent{
                                    data:d.clone()}, 
                        });
         }

    }
    
    pub fn insert(&mut self, peer_id: &PeerId) {
        self.target_peers.insert(*peer_id,SmallVec::new());
    }
    
    
    pub fn remove(&mut self, peer_id: &PeerId) {
        self.target_peers.remove(peer_id);
    }
}

impl Default for Behaviour {
    fn default() -> Self {
        Self::new()
    }
}

impl NetworkBehaviour for Behaviour {
    type ConnectionHandler = Handler;
    type OutEvent = Event;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        Handler::new()
    }

    fn inject_event(&mut self, peer: PeerId, conn_id: ConnectionId, result: protocol::MsgContent) {
        println!("PeerId {:?},ConnId {:?}",peer,conn_id);
        self.events.push_front(NetworkBehaviourAction::GenerateEvent(Event { peer, result }))
    }

    fn poll(
        &mut self,
        _: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        if let Some(e) = self.events.pop_back() {
           Poll::Ready(e)
        } else {
            Poll::Pending
        }
    }
}
